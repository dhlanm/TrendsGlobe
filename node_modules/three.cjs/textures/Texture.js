/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */
var EventDispatcherModule = require('../core/EventDispatcher');
var Vector2Module = require('../math/Vector2');
var MathModule = require('../math/Math');
var Three = require('../Three');
var Texture;
Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
	Object.defineProperty(this, 'id', { value: Three.TextureIdCount++ });
	this.uuid = MathModule.Math.generateUUID();
	this.name = '';
	this.sourceFile = '';
	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];
	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	this.wrapS = wrapS !== undefined ? wrapS : Three.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : Three.ClampToEdgeWrapping;
	this.magFilter = magFilter !== undefined ? magFilter : Three.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : Three.LinearMipMapLinearFilter;
	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	this.format = format !== undefined ? format : Three.RGBAFormat;
	this.type = type !== undefined ? type : Three.UnsignedByteType;
	this.offset = new Vector2Module.Vector2(0, 0);
	this.repeat = new Vector2Module.Vector2(1, 1);
	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;
	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	this._needsUpdate = false;
	this.onUpdate = null;
};
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = Three.UVMapping;
Texture.prototype = {
	constructor: Texture,
	get needsUpdate() {
		return this._needsUpdate;
	},
	set needsUpdate(value) {
		if (value === true)
			this.update();
		this._needsUpdate = value;
	},
	clone: function (texture) {
		if (texture === undefined)
			texture = new Texture();
		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);
		texture.mapping = this.mapping;
		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;
		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;
		texture.anisotropy = this.anisotropy;
		texture.format = this.format;
		texture.type = this.type;
		texture.offset.copy(this.offset);
		texture.repeat.copy(this.repeat);
		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;
		return texture;
	},
	update: function () {
		this.dispatchEvent({ type: 'update' });
	},
	dispose: function () {
		this.dispatchEvent({ type: 'dispose' });
	}
};
EventDispatcherModule.EventDispatcher.prototype.apply(Texture.prototype);
Texture.prototype.isTexture = true;
exports.Texture = Texture;
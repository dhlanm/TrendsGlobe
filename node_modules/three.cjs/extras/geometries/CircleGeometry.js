/**
 * @author hughes
 */
var SphereModule = require('../../math/Sphere');
var Face3Module = require('../../core/Face3');
var Vector2Module = require('../../math/Vector2');
var Vector3Module = require('../../math/Vector3');
var GeometryModule = require('../../core/Geometry');
var CircleGeometry;
CircleGeometry = function (radius, segments, thetaStart, thetaLength) {
	GeometryModule.Geometry.call(this);
	this.type = 'CircleGeometry';
	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	radius = radius || 50;
	segments = segments !== undefined ? Math.max(3, segments) : 8;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	var i, uvs = [], center = new Vector3Module.Vector3(), centerUV = new Vector2Module.Vector2(0.5, 0.5);
	this.vertices.push(center);
	uvs.push(centerUV);
	for (i = 0; i <= segments; i++) {
		var vertex = new Vector3Module.Vector3();
		var segment = thetaStart + i / segments * thetaLength;
		vertex.x = radius * Math.cos(segment);
		vertex.y = radius * Math.sin(segment);
		this.vertices.push(vertex);
		uvs.push(new Vector2Module.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
	}
	var n = new Vector3Module.Vector3(0, 0, 1);
	for (i = 1; i <= segments; i++) {
		this.faces.push(new Face3Module.Face3(i, i + 1, 0, [
			n.clone(),
			n.clone(),
			n.clone()
		]));
		this.faceVertexUvs[0].push([
			uvs[i].clone(),
			uvs[i + 1].clone(),
			centerUV.clone()
		]);
	}
	this.computeFaceNormals();
	this.boundingSphere = new SphereModule.Sphere(new Vector3Module.Vector3(), radius);
};
CircleGeometry.prototype = Object.create(GeometryModule.Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
CircleGeometry.prototype.isCircleGeometry = true;
exports.CircleGeometry = CircleGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/
var Face3Module = require('../../core/Face3');
var Vector3Module = require('../../math/Vector3');
var ShapeUtilsModule = require('../ShapeUtils');
var ExtrudeGeometryModule = require('./ExtrudeGeometry');
var GeometryModule = require('../../core/Geometry');
var ShapeGeometry;
var toString = Object.prototype.toString;
ShapeGeometry = function (shapes, options) {
	GeometryModule.Geometry.call(this);
	this.type = 'ShapeGeometry';
	if (toString.call(shapes).slice(8, -1) === 'Array' === false)
		shapes = [shapes];
	this.addShapeList(shapes, options);
	this.computeFaceNormals();
};
ShapeGeometry.prototype = Object.create(GeometryModule.Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
ShapeGeometry.prototype.addShapeList = function (shapes, options) {
	for (var i = 0, l = shapes.length; i < l; i++) {
		this.addShape(shapes[i], options);
	}
	return this;
};
/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
ShapeGeometry.prototype.addShape = function (shape, options) {
	if (options === undefined)
		options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? ExtrudeGeometryModule.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	//
	var i, l, hole;
	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints(curveSegments);
	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;
	var reverse = !ShapeUtilsModule.ShapeUtils.isClockWise(vertices);
	if (reverse) {
		vertices = vertices.reverse();
		// Maybe we should also check if holes are in the opposite direction, just to be safe...
		for (i = 0, l = holes.length; i < l; i++) {
			hole = holes[i];
			if (ShapeUtilsModule.ShapeUtils.isClockWise(hole)) {
				holes[i] = hole.reverse();
			}
		}
		reverse = false;
	}
	var faces = ShapeUtilsModule.ShapeUtils.triangulateShape(vertices, holes);
	// Vertices
	var contour = vertices;
	for (i = 0, l = holes.length; i < l; i++) {
		hole = holes[i];
		vertices = vertices.concat(hole);
	}
	//
	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	for (i = 0; i < vlen; i++) {
		vert = vertices[i];
		this.vertices.push(new Vector3Module.Vector3(vert.x, vert.y, 0));
	}
	for (i = 0; i < flen; i++) {
		face = faces[i];
		var a = face[0] + shapesOffset;
		var b = face[1] + shapesOffset;
		var c = face[2] + shapesOffset;
		this.faces.push(new Face3Module.Face3(a, b, c, null, null, material));
		this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
	}
};
ShapeGeometry.prototype.isShapeGeometry = true;
exports.ShapeGeometry = ShapeGeometry;
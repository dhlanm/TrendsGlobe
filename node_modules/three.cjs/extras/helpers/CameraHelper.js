/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */
var CameraModule = require('../../cameras/Camera');
var LineModule = require('../../objects/Line');
var ColorModule = require('../../math/Color');
var Vector3Module = require('../../math/Vector3');
var Three = require('../../Three');
var LineBasicMaterialModule = require('../../materials/LineBasicMaterial');
var GeometryModule = require('../../core/Geometry');
var CameraHelper;
CameraHelper = function (camera) {
	var geometry = new GeometryModule.Geometry();
	var material = new LineBasicMaterialModule.LineBasicMaterial({
		color: 16777215,
		vertexColors: Three.FaceColors
	});
	var pointMap = {};
	// colors
	var hexFrustum = 16755200;
	var hexCone = 16711680;
	var hexUp = 43775;
	var hexTarget = 16777215;
	var hexCross = 3355443;
	// near
	addLine('n1', 'n2', hexFrustum);
	addLine('n2', 'n4', hexFrustum);
	addLine('n4', 'n3', hexFrustum);
	addLine('n3', 'n1', hexFrustum);
	// far
	addLine('f1', 'f2', hexFrustum);
	addLine('f2', 'f4', hexFrustum);
	addLine('f4', 'f3', hexFrustum);
	addLine('f3', 'f1', hexFrustum);
	// sides
	addLine('n1', 'f1', hexFrustum);
	addLine('n2', 'f2', hexFrustum);
	addLine('n3', 'f3', hexFrustum);
	addLine('n4', 'f4', hexFrustum);
	// cone
	addLine('p', 'n1', hexCone);
	addLine('p', 'n2', hexCone);
	addLine('p', 'n3', hexCone);
	addLine('p', 'n4', hexCone);
	// up
	addLine('u1', 'u2', hexUp);
	addLine('u2', 'u3', hexUp);
	addLine('u3', 'u1', hexUp);
	// target
	addLine('c', 't', hexTarget);
	addLine('p', 'c', hexCross);
	// cross
	addLine('cn1', 'cn2', hexCross);
	addLine('cn3', 'cn4', hexCross);
	addLine('cf1', 'cf2', hexCross);
	addLine('cf3', 'cf4', hexCross);
	function addLine(a, b, hex) {
		addPoint(a, hex);
		addPoint(b, hex);
	}
	function addPoint(id, hex) {
		geometry.vertices.push(new Vector3Module.Vector3());
		geometry.colors.push(new ColorModule.Color(hex));
		if (pointMap[id] === undefined) {
			pointMap[id] = [];
		}
		pointMap[id].push(geometry.vertices.length - 1);
	}
	LineModule.Line.call(this, geometry, material, Three.LinePieces);
	this.camera = camera;
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;
	this.pointMap = pointMap;
	this.update();
};
CameraHelper.prototype = Object.create(LineModule.Line.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function () {
	var geometry, pointMap;
	var vector = new Vector3Module.Vector3();
	var camera = new CameraModule.Camera();
	var setPoint = function (point, x, y, z) {
		vector.set(x, y, z).unproject(camera);
		var points = pointMap[point];
		if (points !== undefined) {
			for (var i = 0, il = points.length; i < il; i++) {
				geometry.vertices[points[i]].copy(vector);
			}
		}
	};
	return function () {
		geometry = this.geometry;
		pointMap = this.pointMap;
		var w = 1, h = 1;
		// we need just camera projection matrix
		// world matrix must be identity
		camera.projectionMatrix.copy(this.camera.projectionMatrix);
		// center / target
		setPoint('c', 0, 0, -1);
		setPoint('t', 0, 0, 1);
		// near
		setPoint('n1', -w, -h, -1);
		setPoint('n2', w, -h, -1);
		setPoint('n3', -w, h, -1);
		setPoint('n4', w, h, -1);
		// far
		setPoint('f1', -w, -h, 1);
		setPoint('f2', w, -h, 1);
		setPoint('f3', -w, h, 1);
		setPoint('f4', w, h, 1);
		// up
		setPoint('u1', w * 0.7, h * 1.1, -1);
		setPoint('u2', -w * 0.7, h * 1.1, -1);
		setPoint('u3', 0, h * 2, -1);
		// cross
		setPoint('cf1', -w, 0, 1);
		setPoint('cf2', w, 0, 1);
		setPoint('cf3', 0, -h, 1);
		setPoint('cf4', 0, h, 1);
		setPoint('cn1', -w, 0, -1);
		setPoint('cn2', w, 0, -1);
		setPoint('cn3', 0, -h, -1);
		setPoint('cn4', 0, h, -1);
		geometry.verticesNeedUpdate = true;
	};
}();
CameraHelper.prototype.isCameraHelper = true;
exports.CameraHelper = CameraHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var EventDispatcherModule = require('../core/EventDispatcher');
var MathModule = require('../math/Math');
var Three = require('../Three');
var Material;
var instance;
Material = function () {
	Object.defineProperty(this, 'id', { value: Three.MaterialIdCount++ });
	this.uuid = MathModule.Math.generateUUID();
	this.name = '';
	this.type = 'Material';
	this.side = Three.FrontSide;
	this.opacity = 1;
	this.transparent = false;
	this.blending = Three.NormalBlending;
	this.blendSrc = Three.SrcAlphaFactor;
	this.blendDst = Three.OneMinusSrcAlphaFactor;
	this.blendEquation = Three.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;
	this.depthTest = true;
	this.depthWrite = true;
	this.colorWrite = true;
	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;
	this.alphaTest = 0;
	this.overdraw = 0;
	// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	this.visible = true;
	this._needsUpdate = true;
};
Material.prototype = {
	constructor: Material,
	get needsUpdate() {
		return this._needsUpdate;
	},
	set needsUpdate(value) {
		if (value === true)
			this.update();
		this._needsUpdate = value;
	},
	setValues: function (values) {
		if (values === undefined)
			return;
		for (var key in values) {
			var newValue = values[key];
			if (newValue === undefined) {
				Three.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
				continue;
			}
			if (key in this) {
				var currentValue = this[key];
				if (!!(instance = currentValue) && !!instance.isColor) {
					currentValue.set(newValue);
				} else if (!!(instance = currentValue) && !!instance.isVector3 && (!!(instance = newValue) && !!instance.isVector3)) {
					currentValue.copy(newValue);
				} else if (key == 'overdraw') {
					// ensure overdraw is backwards-compatable with legacy boolean type
					this[key] = Number(newValue);
				} else {
					this[key] = newValue;
				}
			}
		}
	},
	toJSON: function () {
		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type
		};
		if (this.name !== '')
			output.name = this.name;
		if (!!(instance = this) && !!instance.isMeshBasicMaterial) {
			output.color = this.color.getHex();
			if (this.vertexColors !== Three.NoColors)
				output.vertexColors = this.vertexColors;
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
			if (this.side !== Three.FrontSide)
				output.side = this.side;
		} else if (!!(instance = this) && !!instance.isMeshLambertMaterial) {
			output.color = this.color.getHex();
			output.emissive = this.emissive.getHex();
			if (this.vertexColors !== Three.NoColors)
				output.vertexColors = this.vertexColors;
			if (this.shading !== Three.SmoothShading)
				output.shading = this.shading;
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
			if (this.side !== Three.FrontSide)
				output.side = this.side;
		} else if (!!(instance = this) && !!instance.isMeshPhongMaterial) {
			output.color = this.color.getHex();
			output.emissive = this.emissive.getHex();
			output.specular = this.specular.getHex();
			output.shininess = this.shininess;
			if (this.vertexColors !== Three.NoColors)
				output.vertexColors = this.vertexColors;
			if (this.shading !== Three.SmoothShading)
				output.shading = this.shading;
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
			if (this.side !== Three.FrontSide)
				output.side = this.side;
		} else if (!!(instance = this) && !!instance.isMeshNormalMaterial) {
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
			if (this.side !== Three.FrontSide)
				output.side = this.side;
		} else if (!!(instance = this) && !!instance.isMeshDepthMaterial) {
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
			if (this.side !== Three.FrontSide)
				output.side = this.side;
		} else if (!!(instance = this) && !!instance.isPointCloudMaterial) {
			output.size = this.size;
			output.sizeAttenuation = this.sizeAttenuation;
			output.color = this.color.getHex();
			if (this.vertexColors !== Three.NoColors)
				output.vertexColors = this.vertexColors;
			if (this.blending !== Three.NormalBlending)
				output.blending = this.blending;
		} else if (!!(instance = this) && !!instance.isShaderMaterial) {
			output.uniforms = this.uniforms;
			output.vertexShader = this.vertexShader;
			output.fragmentShader = this.fragmentShader;
		} else if (!!(instance = this) && !!instance.isSpriteMaterial) {
			output.color = this.color.getHex();
		}
		if (this.opacity < 1)
			output.opacity = this.opacity;
		if (this.transparent !== false)
			output.transparent = this.transparent;
		if (this.wireframe !== false)
			output.wireframe = this.wireframe;
		return output;
	},
	clone: function (material) {
		if (material === undefined)
			material = new Material();
		material.name = this.name;
		material.side = this.side;
		material.opacity = this.opacity;
		material.transparent = this.transparent;
		material.blending = this.blending;
		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;
		material.blendSrcAlpha = this.blendSrcAlpha;
		material.blendDstAlpha = this.blendDstAlpha;
		material.blendEquationAlpha = this.blendEquationAlpha;
		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;
		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;
		material.alphaTest = this.alphaTest;
		material.overdraw = this.overdraw;
		material.visible = this.visible;
		return material;
	},
	update: function () {
		this.dispatchEvent({ type: 'update' });
	},
	dispose: function () {
		this.dispatchEvent({ type: 'dispose' });
	}
};
EventDispatcherModule.EventDispatcher.prototype.apply(Material.prototype);
Material.prototype.isMaterial = true;
exports.Material = Material;
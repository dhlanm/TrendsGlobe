/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */
var Three = require('../Three');
var XHRLoaderModule = require('./XHRLoader');
var CompressedTextureModule = require('../textures/CompressedTexture');
var CompressedTextureLoader;
var toString = Object.prototype.toString;
CompressedTextureLoader = function () {
	// override in sub classes
	this._parser = null;
};
CompressedTextureLoader.prototype = {
	constructor: CompressedTextureLoader,
	load: function (url, onLoad, onError) {
		var scope = this;
		var images = [];
		var texture = new CompressedTextureModule.CompressedTexture();
		texture.image = images;
		var loader = new XHRLoaderModule.XHRLoader();
		loader.setResponseType('arraybuffer');
		if (toString.call(url).slice(8, -1) === 'Array') {
			var loaded = 0;
			var loadTexture = function (i) {
				loader.load(url[i], function (buffer) {
					var texDatas = scope._parser(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;
					if (loaded === 6) {
						if (texDatas.mipmapCount == 1)
							texture.minFilter = Three.LinearFilter;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad)
							onLoad(texture);
					}
				});
			};
			for (var i = 0, il = url.length; i < il; ++i) {
				loadTexture(i);
			}
		} else {
			// compressed cubemap texture stored in a single DDS file
			loader.load(url, function (buffer) {
				var texDatas = scope._parser(buffer, true);
				if (texDatas.isCubemap) {
					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
					for (var f = 0; f < faces; f++) {
						images[f] = { mipmaps: [] };
						for (var i = 0; i < texDatas.mipmapCount; i++) {
							images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
							images[f].format = texDatas.format;
							images[f].width = texDatas.width;
							images[f].height = texDatas.height;
						}
					}
				} else {
					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;
				}
				if (texDatas.mipmapCount === 1) {
					texture.minFilter = Three.LinearFilter;
				}
				texture.format = texDatas.format;
				texture.needsUpdate = true;
				if (onLoad)
					onLoad(texture);
			});
		}
		return texture;
	}
};
CompressedTextureLoader.prototype.isCompressedTextureLoader = true;
exports.CompressedTextureLoader = CompressedTextureLoader;
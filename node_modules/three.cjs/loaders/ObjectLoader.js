/**
 * @author mrdoob / http://mrdoob.com/
 */
var Object3DModule = require('../core/Object3D');
var GroupModule = require('../objects/Group');
var SpriteModule = require('../objects/Sprite');
var PointCloudModule = require('../objects/PointCloud');
var LineModule = require('../objects/Line');
var MeshModule = require('../objects/Mesh');
var HemisphereLightModule = require('../lights/HemisphereLight');
var SpotLightModule = require('../lights/SpotLight');
var PointLightModule = require('../lights/PointLight');
var DirectionalLightModule = require('../lights/DirectionalLight');
var AmbientLightModule = require('../lights/AmbientLight');
var OrthographicCameraModule = require('../cameras/OrthographicCamera');
var PerspectiveCameraModule = require('../cameras/PerspectiveCamera');
var SceneModule = require('../scenes/Scene');
var Matrix4Module = require('../math/Matrix4');
var TextureModule = require('../textures/Texture');
var ImageLoaderModule = require('./ImageLoader');
var Vector2Module = require('../math/Vector2');
var MaterialLoaderModule = require('./MaterialLoader');
var Three = require('../Three');
var TorusKnotGeometryModule = require('../extras/geometries/TorusKnotGeometry');
var TorusGeometryModule = require('../extras/geometries/TorusGeometry');
var IcosahedronGeometryModule = require('../extras/geometries/IcosahedronGeometry');
var SphereGeometryModule = require('../extras/geometries/SphereGeometry');
var CylinderGeometryModule = require('../extras/geometries/CylinderGeometry');
var CircleGeometryModule = require('../extras/geometries/CircleGeometry');
var BoxGeometryModule = require('../extras/geometries/BoxGeometry');
var PlaneBufferGeometryModule = require('../extras/geometries/PlaneBufferGeometry');
var PlaneGeometryModule = require('../extras/geometries/PlaneGeometry');
var BufferGeometryLoaderModule = require('./BufferGeometryLoader');
var JSONLoaderModule = require('./JSONLoader');
var XHRLoaderModule = require('./XHRLoader');
var LoadingManagerModule = require('./LoadingManager');
var ObjectLoader;
var toString = Object.prototype.toString;
ObjectLoader = function (manager) {
	this.manager = manager !== undefined ? manager : LoadingManagerModule.DefaultLoadingManager;
	this.texturePath = '';
};
ObjectLoader.prototype = {
	constructor: ObjectLoader,
	load: function (url, onLoad, onProgress, onError) {
		if (this.texturePath === '') {
			this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
		}
		var scope = this;
		var loader = new XHRLoaderModule.XHRLoader(scope.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.load(url, function (text) {
			scope.parse(JSON.parse(text), onLoad);
		}, onProgress, onError);
	},
	setTexturePath: function (value) {
		this.texturePath = value;
	},
	setCrossOrigin: function (value) {
		this.crossOrigin = value;
	},
	parse: function (json, onLoad) {
		var geometries = this.parseGeometries(json.geometries);
		var images = this.parseImages(json.images, function () {
			if (onLoad !== undefined)
				onLoad(object);
		});
		var textures = this.parseTextures(json.textures, images);
		var materials = this.parseMaterials(json.materials, textures);
		var object = this.parseObject(json.object, geometries, materials);
		if (json.images === undefined || json.images.length === 0) {
			if (onLoad !== undefined)
				onLoad(object);
		}
		return object;
	},
	parseGeometries: function (json) {
		var geometries = {};
		if (json !== undefined) {
			var geometryLoader = new JSONLoaderModule.JSONLoader();
			var bufferGeometryLoader = new BufferGeometryLoaderModule.BufferGeometryLoader();
			for (var i = 0, l = json.length; i < l; i++) {
				var geometry;
				var data = json[i];
				switch (data.type) {
				case 'PlaneGeometry':
					geometry = new PlaneGeometryModule.PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
					break;
				case 'PlaneBufferGeometry':
					geometry = new PlaneBufferGeometryModule.PlaneBufferGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
					break;
				case 'BoxGeometry':
				case 'CubeGeometry':
					// backwards compatible
					geometry = new BoxGeometryModule.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
					break;
				case 'CircleGeometry':
					geometry = new CircleGeometryModule.CircleGeometry(data.radius, data.segments);
					break;
				case 'CylinderGeometry':
					geometry = new CylinderGeometryModule.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded);
					break;
				case 'SphereGeometry':
					geometry = new SphereGeometryModule.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
					break;
				case 'IcosahedronGeometry':
					geometry = new IcosahedronGeometryModule.IcosahedronGeometry(data.radius, data.detail);
					break;
				case 'TorusGeometry':
					geometry = new TorusGeometryModule.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
					break;
				case 'TorusKnotGeometry':
					geometry = new TorusKnotGeometryModule.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
					break;
				case 'BufferGeometry':
					geometry = bufferGeometryLoader.parse(data);
					break;
				case 'Geometry':
					geometry = geometryLoader.parse(data.data).geometry;
					break;
				}
				geometry.uuid = data.uuid;
				if (data.name !== undefined)
					geometry.name = data.name;
				geometries[data.uuid] = geometry;
			}
		}
		return geometries;
	},
	parseMaterials: function (json, textures) {
		var materials = {};
		if (json !== undefined) {
			var getTexture = function (name) {
				if (textures[name] === undefined) {
					Three.warn('THREE.ObjectLoader: Undefined texture', name);
				}
				return textures[name];
			};
			var loader = new MaterialLoaderModule.MaterialLoader();
			for (var i = 0, l = json.length; i < l; i++) {
				var data = json[i];
				var material = loader.parse(data);
				material.uuid = data.uuid;
				if (data.name !== undefined)
					material.name = data.name;
				if (data.map !== undefined) {
					material.map = getTexture(data.map);
				}
				if (data.bumpMap !== undefined) {
					material.bumpMap = getTexture(data.bumpMap);
					if (data.bumpScale) {
						material.bumpScale = new Vector2Module.Vector2(data.bumpScale, data.bumpScale);
					}
				}
				if (data.alphaMap !== undefined) {
					material.alphaMap = getTexture(data.alphaMap);
				}
				if (data.envMap !== undefined) {
					material.envMap = getTexture(data.envMap);
				}
				if (data.normalMap !== undefined) {
					material.normalMap = getTexture(data.normalMap);
					if (data.normalScale) {
						material.normalScale = new Vector2Module.Vector2(data.normalScale, data.normalScale);
					}
				}
				if (data.lightMap !== undefined) {
					material.lightMap = getTexture(data.lightMap);
				}
				if (data.specularMap !== undefined) {
					material.specularMap = getTexture(data.specularMap);
				}
				materials[data.uuid] = material;
			}
		}
		return materials;
	},
	parseImages: function (json, onLoad) {
		var scope = this;
		var images = {};
		if (json !== undefined && json.length > 0) {
			var manager = new LoadingManagerModule.LoadingManager(onLoad);
			var loader = new ImageLoaderModule.ImageLoader(manager);
			loader.setCrossOrigin(this.crossOrigin);
			var loadImage = function (url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				});
			};
			for (var i = 0, l = json.length; i < l; i++) {
				var image = json[i];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
				images[image.uuid] = loadImage(path);
			}
		}
		return images;
	},
	parseTextures: function (json, images) {
		var textures = {};
		var filterLookup = {
			NearestFilter: Three.NearestFilter,
			NearestMipMapNearestFilter: Three.NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: Three.NearestMipMapLinearFilter,
			LinearFilter: Three.LinearFilter,
			LinearMipMapNearestFilter: Three.LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: Three.LinearMipMapLinearFilter
		};
		var wrappingLookup = {
			RepeatWrapping: Three.RepeatWrapping,
			ClampToEdgeWrapping: Three.ClampToEdgeWrapping,
			MirroredRepeatWrapping: Three.MirroredRepeatWrapping
		};
		if (json !== undefined) {
			for (var i = 0, l = json.length; i < l; i++) {
				var data = json[i];
				if (data.image === undefined) {
					Three.warn('THREE.ObjectLoader: No "image" speficied for', data.uuid);
				}
				if (images[data.image] === undefined) {
					Three.warn('THREE.ObjectLoader: Undefined image', data.image);
				}
				var texture = new TextureModule.Texture(images[data.image]);
				texture.needsUpdate = true;
				texture.uuid = data.uuid;
				if (data.name !== undefined)
					texture.name = data.name;
				if (data.repeat !== undefined)
					texture.repeat = new Vector2Module.Vector2(data.repeat[0], data.repeat[1]);
				if (data.minFilter !== undefined)
					texture.minFilter = filterLookup[data.minFilter];
				if (data.magFilter !== undefined)
					texture.magFilter = filterLookup[data.magFilter];
				if (data.anisotropy !== undefined)
					texture.anisotropy = data.anisotropy;
				if (toString.call(data.wrap).slice(8, -1) === 'Array') {
					texture.wrapS = wrappingLookup[data.wrap[0]];
					texture.wrapT = wrappingLookup[data.wrap[1]];
				}
				textures[data.uuid] = texture;
			}
		}
		return textures;
	},
	parseObject: function () {
		var matrix = new Matrix4Module.Matrix4();
		return function (data, geometries, materials) {
			var object;
			var getGeometry = function (name) {
				if (geometries[name] === undefined) {
					Three.warn('THREE.ObjectLoader: Undefined geometry', name);
				}
				return geometries[name];
			};
			var getMaterial = function (name) {
				if (materials[name] === undefined) {
					Three.warn('THREE.ObjectLoader: Undefined material', name);
				}
				return materials[name];
			};
			switch (data.type) {
			case 'Scene':
				object = new SceneModule.Scene();
				break;
			case 'PerspectiveCamera':
				object = new PerspectiveCameraModule.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
				break;
			case 'OrthographicCamera':
				object = new OrthographicCameraModule.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
				break;
			case 'AmbientLight':
				object = new AmbientLightModule.AmbientLight(data.color);
				break;
			case 'DirectionalLight':
				object = new DirectionalLightModule.DirectionalLight(data.color, data.intensity);
				break;
			case 'PointLight':
				object = new PointLightModule.PointLight(data.color, data.intensity, data.distance, data.decay);
				break;
			case 'SpotLight':
				object = new SpotLightModule.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
				break;
			case 'HemisphereLight':
				object = new HemisphereLightModule.HemisphereLight(data.color, data.groundColor, data.intensity);
				break;
			case 'Mesh':
				object = new MeshModule.Mesh(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'Line':
				object = new LineModule.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
				break;
			case 'PointCloud':
				object = new PointCloudModule.PointCloud(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'Sprite':
				object = new SpriteModule.Sprite(getMaterial(data.material));
				break;
			case 'Group':
				object = new GroupModule.Group();
				break;
			default:
				object = new Object3DModule.Object3D();
			}
			object.uuid = data.uuid;
			if (data.name !== undefined)
				object.name = data.name;
			if (data.matrix !== undefined) {
				matrix.fromArray(data.matrix);
				matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined)
					object.position.fromArray(data.position);
				if (data.rotation !== undefined)
					object.rotation.fromArray(data.rotation);
				if (data.scale !== undefined)
					object.scale.fromArray(data.scale);
			}
			if (data.visible !== undefined)
				object.visible = data.visible;
			if (data.userData !== undefined)
				object.userData = data.userData;
			if (data.children !== undefined) {
				for (var child in data.children) {
					object.add(this.parseObject(data.children[child], geometries, materials));
				}
			}
			return object;
		};
	}()
};
ObjectLoader.prototype.isObjectLoader = true;
exports.ObjectLoader = ObjectLoader;
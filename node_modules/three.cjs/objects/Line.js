/**
 * @author mrdoob / http://mrdoob.com/
 */
var Vector3Module = require('../math/Vector3');
var SphereModule = require('../math/Sphere');
var RayModule = require('../math/Ray');
var Matrix4Module = require('../math/Matrix4');
var Three = require('../Three');
var LineBasicMaterialModule = require('../materials/LineBasicMaterial');
var GeometryModule = require('../core/Geometry');
var Object3DModule = require('../core/Object3D');
var Line;
var instance;
Line = function (geometry, material, mode) {
	Object3DModule.Object3D.call(this);
	this.type = 'Line';
	this.geometry = geometry !== undefined ? geometry : new GeometryModule.Geometry();
	this.material = material !== undefined ? material : new LineBasicMaterialModule.LineBasicMaterial({ color: Math.random() * 16777215 });
	this.mode = mode !== undefined ? mode : Three.LineStrip;
};
Line.prototype = Object.create(Object3DModule.Object3D.prototype);
Line.prototype.constructor = Line;
Line.prototype.raycast = function () {
	var inverseMatrix = new Matrix4Module.Matrix4();
	var ray = new RayModule.Ray();
	var sphere = new SphereModule.Sphere();
	return function (raycaster, intersects) {
		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;
		var geometry = this.geometry;
		if (geometry.boundingSphere === null)
			geometry.computeBoundingSphere();
		// Checking boundingSphere distance to ray
		sphere.copy(geometry.boundingSphere);
		sphere.applyMatrix4(this.matrixWorld);
		if (raycaster.ray.isIntersectionSphere(sphere) === false) {
			return;
		}
		inverseMatrix.getInverse(this.matrixWorld);
		ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
		var vStart = new Vector3Module.Vector3();
		var vEnd = new Vector3Module.Vector3();
		var interSegment = new Vector3Module.Vector3();
		var interRay = new Vector3Module.Vector3();
		var step = this.mode === Three.LineStrip ? 1 : 2;
		if (!!(instance = geometry) && !!instance.isBufferGeometry) {
			var attributes = geometry.attributes;
			if (attributes.index !== undefined) {
				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;
				if (offsets.length === 0) {
					offsets = [{
							start: 0,
							count: indices.length,
							index: 0
						}];
				}
				for (var oi = 0; oi < offsets.length; oi++) {
					var start = offsets[oi].start;
					var count = offsets[oi].count;
					var index = offsets[oi].index;
					for (var i = start; i < start + count - 1; i += step) {
						var a = index + indices[i];
						var b = index + indices[i + 1];
						vStart.fromArray(positions, a * 3);
						vEnd.fromArray(positions, b * 3);
						var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
						if (distSq > precisionSq)
							continue;
						var distance = ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far)
							continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							offsetIndex: oi,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else {
				var positions = attributes.position.array;
				for (var i = 0; i < positions.length / 3 - 1; i += step) {
					vStart.fromArray(positions, 3 * i);
					vEnd.fromArray(positions, 3 * i + 3);
					var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
					if (distSq > precisionSq)
						continue;
					var distance = ray.origin.distanceTo(interRay);
					if (distance < raycaster.near || distance > raycaster.far)
						continue;
					intersects.push({
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4(this.matrixWorld),
						index: i,
						face: null,
						faceIndex: null,
						object: this
					});
				}
			}
		} else if (!!(instance = geometry) && !!instance.isGeometry) {
			var vertices = geometry.vertices;
			var nbVertices = vertices.length;
			for (var i = 0; i < nbVertices - 1; i += step) {
				var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
				if (distSq > precisionSq)
					continue;
				var distance = ray.origin.distanceTo(interRay);
				if (distance < raycaster.near || distance > raycaster.far)
					continue;
				intersects.push({
					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				});
			}
		}
	};
}();
Line.prototype.clone = function (object) {
	if (object === undefined)
		object = new Line(this.geometry, this.material, this.mode);
	Object3DModule.Object3D.prototype.clone.call(this, object);
	return object;
};
Line.prototype.isLine = true;
exports.Line = Line;
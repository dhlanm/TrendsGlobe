/**
 * @author alteredq / http://alteredqualia.com/
 */
var Three = require('../Three');
var Vector3Module = require('../math/Vector3');
var RayModule = require('../math/Ray');
var Matrix4Module = require('../math/Matrix4');
var PointCloudMaterialModule = require('../materials/PointCloudMaterial');
var GeometryModule = require('../core/Geometry');
var Object3DModule = require('../core/Object3D');
var ParticleSystem;
var PointCloud;
var instance;
PointCloud = function (geometry, material) {
	Object3DModule.Object3D.call(this);
	this.type = 'PointCloud';
	this.geometry = geometry !== undefined ? geometry : new GeometryModule.Geometry();
	this.material = material !== undefined ? material : new PointCloudMaterialModule.PointCloudMaterial({ color: Math.random() * 16777215 });
};
PointCloud.prototype = Object.create(Object3DModule.Object3D.prototype);
PointCloud.prototype.constructor = PointCloud;
PointCloud.prototype.raycast = function () {
	var inverseMatrix = new Matrix4Module.Matrix4();
	var ray = new RayModule.Ray();
	return function (raycaster, intersects) {
		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.PointCloud.threshold;
		inverseMatrix.getInverse(this.matrixWorld);
		ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
		if (geometry.boundingBox !== null) {
			if (ray.isIntersectionBox(geometry.boundingBox) === false) {
				return;
			}
		}
		var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
		var position = new Vector3Module.Vector3();
		var testPoint = function (point, index) {
			var rayPointDistance = ray.distanceToPoint(point);
			if (rayPointDistance < localThreshold) {
				var intersectPoint = ray.closestPointToPoint(point);
				intersectPoint.applyMatrix4(object.matrixWorld);
				var distance = raycaster.ray.origin.distanceTo(intersectPoint);
				intersects.push({
					distance: distance,
					distanceToRay: rayPointDistance,
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object
				});
			}
		};
		if (!!(instance = geometry) && !!instance.isBufferGeometry) {
			var attributes = geometry.attributes;
			var positions = attributes.position.array;
			if (attributes.index !== undefined) {
				var indices = attributes.index.array;
				var offsets = geometry.offsets;
				if (offsets.length === 0) {
					var offset = {
						start: 0,
						count: indices.length,
						index: 0
					};
					offsets = [offset];
				}
				for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {
					var start = offsets[oi].start;
					var count = offsets[oi].count;
					var index = offsets[oi].index;
					for (var i = start, il = start + count; i < il; i++) {
						var a = index + indices[i];
						position.fromArray(positions, a * 3);
						testPoint(position, a);
					}
				}
			} else {
				var pointCount = positions.length / 3;
				for (var i = 0; i < pointCount; i++) {
					position.set(positions[3 * i], positions[3 * i + 1], positions[3 * i + 2]);
					testPoint(position, i);
				}
			}
		} else {
			var vertices = this.geometry.vertices;
			for (var i = 0; i < vertices.length; i++) {
				testPoint(vertices[i], i);
			}
		}
	};
}();
PointCloud.prototype.clone = function (object) {
	if (object === undefined)
		object = new PointCloud(this.geometry, this.material);
	Object3DModule.Object3D.prototype.clone.call(this, object);
	return object;
};
// Backwards compatibility
ParticleSystem = function (geometry, material) {
	Three.warn('THREE.ParticleSystem has been renamed to THREE.PointCloud.');
	return new PointCloud(geometry, material);
};
PointCloud.prototype.isPointCloud = true;
exports.PointCloud = PointCloud;
ParticleSystem.prototype.isParticleSystem = true;
exports.ParticleSystem = ParticleSystem;
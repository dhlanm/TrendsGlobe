/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */
var Three = require('../Three');
var SkeletonModule = require('./Skeleton');
var BoneModule = require('./Bone');
var Matrix4Module = require('../math/Matrix4');
var MeshModule = require('./Mesh');
var SkinnedMesh;
var instance;
SkinnedMesh = function (geometry, material, useVertexTexture) {
	MeshModule.Mesh.call(this, geometry, material);
	this.type = 'SkinnedMesh';
	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4Module.Matrix4();
	this.bindMatrixInverse = new Matrix4Module.Matrix4();
	// init bones
	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.
	var bones = [];
	if (this.geometry && this.geometry.bones !== undefined) {
		var bone, gbone, p, q, s;
		for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
			gbone = this.geometry.bones[b];
			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;
			bone = new BoneModule.Bone(this);
			bones.push(bone);
			bone.name = gbone.name;
			bone.position.set(p[0], p[1], p[2]);
			bone.quaternion.set(q[0], q[1], q[2], q[3]);
			if (s !== undefined) {
				bone.scale.set(s[0], s[1], s[2]);
			} else {
				bone.scale.set(1, 1, 1);
			}
		}
		for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
			gbone = this.geometry.bones[b];
			if (gbone.parent !== -1) {
				bones[gbone.parent].add(bones[b]);
			} else {
				this.add(bones[b]);
			}
		}
	}
	this.normalizeSkinWeights();
	this.updateMatrixWorld(true);
	this.bind(new SkeletonModule.Skeleton(bones, undefined, useVertexTexture));
};
SkinnedMesh.prototype = Object.create(MeshModule.Mesh.prototype);
SkinnedMesh.prototype.constructor = SkinnedMesh;
SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {
	this.skeleton = skeleton;
	if (bindMatrix === undefined) {
		this.updateMatrixWorld(true);
		bindMatrix = this.matrixWorld;
	}
	this.bindMatrix.copy(bindMatrix);
	this.bindMatrixInverse.getInverse(bindMatrix);
};
SkinnedMesh.prototype.pose = function () {
	this.skeleton.pose();
};
SkinnedMesh.prototype.normalizeSkinWeights = function () {
	if (!!(instance = this.geometry) && !!instance.isGeometry) {
		for (var i = 0; i < this.geometry.skinIndices.length; i++) {
			var sw = this.geometry.skinWeights[i];
			var scale = 1 / sw.lengthManhattan();
			if (scale !== Infinity) {
				sw.multiplyScalar(scale);
			} else {
				sw.set(1);	// this will be normalized by the shader anyway
			}
		}
	} else {
	}
};
SkinnedMesh.prototype.updateMatrixWorld = function (force) {
	MeshModule.Mesh.prototype.updateMatrixWorld.call(this, true);
	if (this.bindMode === 'attached') {
		this.bindMatrixInverse.getInverse(this.matrixWorld);
	} else if (this.bindMode === 'detached') {
		this.bindMatrixInverse.getInverse(this.bindMatrix);
	} else {
		Three.warn('THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode);
	}
};
SkinnedMesh.prototype.clone = function (object) {
	if (object === undefined) {
		object = new SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
	}
	MeshModule.Mesh.prototype.clone.call(this, object);
	return object;
};
SkinnedMesh.prototype.isSkinnedMesh = true;
exports.SkinnedMesh = SkinnedMesh;
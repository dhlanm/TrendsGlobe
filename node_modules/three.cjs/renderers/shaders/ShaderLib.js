/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */
var Vector3Module = require('../../math/Vector3');
var ColorModule = require('../../math/Color');
var ShaderChunkModule = require('./ShaderChunk');
var UniformsLibModule = require('./UniformsLib');
var UniformsUtilsModule = require('./UniformsUtils');
var ShaderLib;
ShaderLib = {
	'basic': {
		uniforms: UniformsUtilsModule.UniformsUtils.merge([
			UniformsLibModule.UniformsLib['common'],
			UniformsLibModule.UniformsLib['fog'],
			UniformsLibModule.UniformsLib['shadowmap']
		]),
		vertexShader: [
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['map_pars_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['color_pars_vertex'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_pars_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['map_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_vertex'],
			ShaderChunkModule.ShaderChunk['color_vertex'],
			ShaderChunkModule.ShaderChunk['skinbase_vertex'],
			'\t#ifdef USE_ENVMAP',
			ShaderChunkModule.ShaderChunk['morphnormal_vertex'],
			ShaderChunkModule.ShaderChunk['skinnormal_vertex'],
			ShaderChunkModule.ShaderChunk['defaultnormal_vertex'],
			'\t#endif',
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			ShaderChunkModule.ShaderChunk['worldpos_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform vec3 diffuse;',
			'uniform float opacity;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_fragment'],
			ShaderChunkModule.ShaderChunk['map_pars_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['envmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['fog_pars_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tvec3 outgoingLight = vec3( 0.0 );',
			// outgoing light does not have an alpha, the surface does
			'\tvec4 diffuseColor = vec4( diffuse, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			ShaderChunkModule.ShaderChunk['map_fragment'],
			ShaderChunkModule.ShaderChunk['color_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_fragment'],
			ShaderChunkModule.ShaderChunk['alphatest_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_fragment'],
			'\toutgoingLight = diffuseColor.rgb;',
			// simple shader
			ShaderChunkModule.ShaderChunk['lightmap_fragment'],
			// TODO: Light map on an otherwise unlit surface doesn't make sense.
			ShaderChunkModule.ShaderChunk['envmap_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_fragment'],
			// TODO: Shadows on an otherwise unlit surface doesn't make sense.
			ShaderChunkModule.ShaderChunk['linear_to_gamma_fragment'],
			ShaderChunkModule.ShaderChunk['fog_fragment'],
			'\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'lambert': {
		uniforms: UniformsUtilsModule.UniformsUtils.merge([
			UniformsLibModule.UniformsLib['common'],
			UniformsLibModule.UniformsLib['fog'],
			UniformsLibModule.UniformsLib['lights'],
			UniformsLibModule.UniformsLib['shadowmap'],
			{
				'emissive': {
					type: 'c',
					value: new ColorModule.Color(0)
				},
				'wrapRGB': {
					type: 'v3',
					value: new Vector3Module.Vector3(1, 1, 1)
				}
			}
		]),
		vertexShader: [
			'#define LAMBERT',
			'varying vec3 vLightFront;',
			'#ifdef DOUBLE_SIDED',
			'\tvarying vec3 vLightBack;',
			'#endif',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['map_pars_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['lights_lambert_pars_vertex'],
			ShaderChunkModule.ShaderChunk['color_pars_vertex'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_pars_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['map_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_vertex'],
			ShaderChunkModule.ShaderChunk['color_vertex'],
			ShaderChunkModule.ShaderChunk['morphnormal_vertex'],
			ShaderChunkModule.ShaderChunk['skinbase_vertex'],
			ShaderChunkModule.ShaderChunk['skinnormal_vertex'],
			ShaderChunkModule.ShaderChunk['defaultnormal_vertex'],
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			ShaderChunkModule.ShaderChunk['worldpos_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_vertex'],
			ShaderChunkModule.ShaderChunk['lights_lambert_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform vec3 diffuse;',
			'uniform vec3 emissive;',
			'uniform float opacity;',
			'varying vec3 vLightFront;',
			'#ifdef DOUBLE_SIDED',
			'\tvarying vec3 vLightBack;',
			'#endif',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_fragment'],
			ShaderChunkModule.ShaderChunk['map_pars_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['envmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['fog_pars_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tvec3 outgoingLight = vec3( 0.0 );',
			// outgoing light does not have an alpha, the surface does
			'\tvec4 diffuseColor = vec4( diffuse, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			ShaderChunkModule.ShaderChunk['map_fragment'],
			ShaderChunkModule.ShaderChunk['color_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_fragment'],
			ShaderChunkModule.ShaderChunk['alphatest_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_fragment'],
			'\t#ifdef DOUBLE_SIDED',
			//"float isFront = float( gl_FrontFacing );",
			//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
			'\t\tif ( gl_FrontFacing )',
			'\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;',
			'\t\telse',
			'\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;',
			'\t#else',
			'\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;',
			'\t#endif',
			ShaderChunkModule.ShaderChunk['lightmap_fragment'],
			ShaderChunkModule.ShaderChunk['envmap_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_fragment'],
			ShaderChunkModule.ShaderChunk['linear_to_gamma_fragment'],
			ShaderChunkModule.ShaderChunk['fog_fragment'],
			'\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'phong': {
		uniforms: UniformsUtilsModule.UniformsUtils.merge([
			UniformsLibModule.UniformsLib['common'],
			UniformsLibModule.UniformsLib['bump'],
			UniformsLibModule.UniformsLib['normalmap'],
			UniformsLibModule.UniformsLib['fog'],
			UniformsLibModule.UniformsLib['lights'],
			UniformsLibModule.UniformsLib['shadowmap'],
			{
				'emissive': {
					type: 'c',
					value: new ColorModule.Color(0)
				},
				'specular': {
					type: 'c',
					value: new ColorModule.Color(1118481)
				},
				'shininess': {
					type: 'f',
					value: 30
				},
				'wrapRGB': {
					type: 'v3',
					value: new Vector3Module.Vector3(1, 1, 1)
				}
			}
		]),
		vertexShader: [
			'#define PHONG',
			'varying vec3 vViewPosition;',
			'#ifndef FLAT_SHADED',
			'\tvarying vec3 vNormal;',
			'#endif',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['map_pars_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['lights_phong_pars_vertex'],
			ShaderChunkModule.ShaderChunk['color_pars_vertex'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_pars_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['map_vertex'],
			ShaderChunkModule.ShaderChunk['lightmap_vertex'],
			ShaderChunkModule.ShaderChunk['color_vertex'],
			ShaderChunkModule.ShaderChunk['morphnormal_vertex'],
			ShaderChunkModule.ShaderChunk['skinbase_vertex'],
			ShaderChunkModule.ShaderChunk['skinnormal_vertex'],
			ShaderChunkModule.ShaderChunk['defaultnormal_vertex'],
			'#ifndef FLAT_SHADED',
			// Normal computed with derivatives when FLAT_SHADED
			'\tvNormal = normalize( transformedNormal );',
			'#endif',
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'\tvViewPosition = -mvPosition.xyz;',
			ShaderChunkModule.ShaderChunk['worldpos_vertex'],
			ShaderChunkModule.ShaderChunk['envmap_vertex'],
			ShaderChunkModule.ShaderChunk['lights_phong_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'#define PHONG',
			'uniform vec3 diffuse;',
			'uniform vec3 emissive;',
			'uniform vec3 specular;',
			'uniform float shininess;',
			'uniform float opacity;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_fragment'],
			ShaderChunkModule.ShaderChunk['map_pars_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['lightmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['envmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['fog_pars_fragment'],
			ShaderChunkModule.ShaderChunk['lights_phong_pars_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['bumpmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['normalmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tvec3 outgoingLight = vec3( 0.0 );',
			// outgoing light does not have an alpha, the surface does
			'\tvec4 diffuseColor = vec4( diffuse, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			ShaderChunkModule.ShaderChunk['map_fragment'],
			ShaderChunkModule.ShaderChunk['color_fragment'],
			ShaderChunkModule.ShaderChunk['alphamap_fragment'],
			ShaderChunkModule.ShaderChunk['alphatest_fragment'],
			ShaderChunkModule.ShaderChunk['specularmap_fragment'],
			ShaderChunkModule.ShaderChunk['lights_phong_fragment'],
			ShaderChunkModule.ShaderChunk['lightmap_fragment'],
			ShaderChunkModule.ShaderChunk['envmap_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_fragment'],
			ShaderChunkModule.ShaderChunk['linear_to_gamma_fragment'],
			ShaderChunkModule.ShaderChunk['fog_fragment'],
			'\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'particle_basic': {
		uniforms: UniformsUtilsModule.UniformsUtils.merge([
			UniformsLibModule.UniformsLib['particle'],
			UniformsLibModule.UniformsLib['shadowmap']
		]),
		vertexShader: [
			'uniform float size;',
			'uniform float scale;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['color_vertex'],
			'\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
			'\t#ifdef USE_SIZEATTENUATION',
			'\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );',
			'\t#else',
			'\t\tgl_PointSize = size;',
			'\t#endif',
			'\tgl_Position = projectionMatrix * mvPosition;',
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			ShaderChunkModule.ShaderChunk['worldpos_vertex'],
			ShaderChunkModule.ShaderChunk['shadowmap_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform vec3 psColor;',
			'uniform float opacity;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_fragment'],
			ShaderChunkModule.ShaderChunk['map_particle_pars_fragment'],
			ShaderChunkModule.ShaderChunk['fog_pars_fragment'],
			ShaderChunkModule.ShaderChunk['shadowmap_pars_fragment'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tvec3 outgoingLight = vec3( 0.0 );',
			// outgoing light does not have an alpha, the surface does
			'\tvec4 diffuseColor = vec4( psColor, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			ShaderChunkModule.ShaderChunk['map_particle_fragment'],
			ShaderChunkModule.ShaderChunk['color_fragment'],
			ShaderChunkModule.ShaderChunk['alphatest_fragment'],
			'\toutgoingLight = diffuseColor.rgb;',
			// simple shader
			ShaderChunkModule.ShaderChunk['shadowmap_fragment'],
			ShaderChunkModule.ShaderChunk['fog_fragment'],
			'\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'dashed': {
		uniforms: UniformsUtilsModule.UniformsUtils.merge([
			UniformsLibModule.UniformsLib['common'],
			UniformsLibModule.UniformsLib['fog'],
			{
				'scale': {
					type: 'f',
					value: 1
				},
				'dashSize': {
					type: 'f',
					value: 1
				},
				'totalSize': {
					type: 'f',
					value: 2
				}
			}
		]),
		vertexShader: [
			'uniform float scale;',
			'attribute float lineDistance;',
			'varying float vLineDistance;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['color_vertex'],
			'\tvLineDistance = scale * lineDistance;',
			'\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
			'\tgl_Position = projectionMatrix * mvPosition;',
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform vec3 diffuse;',
			'uniform float opacity;',
			'uniform float dashSize;',
			'uniform float totalSize;',
			'varying float vLineDistance;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['color_pars_fragment'],
			ShaderChunkModule.ShaderChunk['fog_pars_fragment'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tif ( mod( vLineDistance, totalSize ) > dashSize ) {',
			'\t\tdiscard;',
			'\t}',
			'\tvec3 outgoingLight = vec3( 0.0 );',
			// outgoing light does not have an alpha, the surface does
			'\tvec4 diffuseColor = vec4( diffuse, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			ShaderChunkModule.ShaderChunk['color_fragment'],
			'\toutgoingLight = diffuseColor.rgb;',
			// simple shader
			ShaderChunkModule.ShaderChunk['fog_fragment'],
			'\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'depth': {
		uniforms: {
			'mNear': {
				type: 'f',
				value: 1
			},
			'mFar': {
				type: 'f',
				value: 2000
			},
			'opacity': {
				type: 'f',
				value: 1
			}
		},
		vertexShader: [
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform float mNear;',
			'uniform float mFar;',
			'uniform float opacity;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			'\t#ifdef USE_LOGDEPTHBUF_EXT',
			'\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;',
			'\t#else',
			'\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;',
			'\t#endif',
			'\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );',
			'\tgl_FragColor = vec4( vec3( color ), opacity );',
			// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
			'}'
		].join('\n')
	},
	'normal': {
		uniforms: {
			'opacity': {
				type: 'f',
				value: 1
			}
		},
		vertexShader: [
			'varying vec3 vNormal;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			'\tvNormal = normalize( normalMatrix * normal );',
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform float opacity;',
			'varying vec3 vNormal;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			'}'
		].join('\n')
	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */
	'cube': {
		uniforms: {
			'tCube': {
				type: 't',
				value: null
			},
			'tFlip': {
				type: 'f',
				value: -1
			}
		},
		vertexShader: [
			'varying vec3 vWorldPosition;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			'\tvWorldPosition = transformDirection( position, modelMatrix );',
			'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform samplerCube tCube;',
			'uniform float tFlip;',
			'varying vec3 vWorldPosition;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			'\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			'}'
		].join('\n')
	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */
	'equirect': {
		uniforms: {
			'tEquirect': {
				type: 't',
				value: null
			},
			'tFlip': {
				type: 'f',
				value: -1
			}
		},
		vertexShader: [
			'varying vec3 vWorldPosition;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			'\tvWorldPosition = transformDirection( position, modelMatrix );',
			'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			'uniform sampler2D tEquirect;',
			'uniform float tFlip;',
			'varying vec3 vWorldPosition;',
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'void main() {',
			// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
			'vec3 direction = normalize( vWorldPosition );',
			'vec2 sampleUV;',
			'sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );',
			'sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;',
			'gl_FragColor = texture2D( tEquirect, sampleUV );',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			'}'
		].join('\n')
	},
	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */
	'depthRGBA': {
		uniforms: {},
		vertexShader: [
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['morphtarget_pars_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_pars_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_vertex'],
			'void main() {',
			ShaderChunkModule.ShaderChunk['skinbase_vertex'],
			ShaderChunkModule.ShaderChunk['morphtarget_vertex'],
			ShaderChunkModule.ShaderChunk['skinning_vertex'],
			ShaderChunkModule.ShaderChunk['default_vertex'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_vertex'],
			'}'
		].join('\n'),
		fragmentShader: [
			ShaderChunkModule.ShaderChunk['common'],
			ShaderChunkModule.ShaderChunk['logdepthbuf_pars_fragment'],
			'vec4 pack_depth( const in float depth ) {',
			'\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );',
			'\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );',
			'\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );',
			// "	vec4 res = fract( depth * bit_shift );",
			'\tres -= res.xxyz * bit_mask;',
			'\treturn res;',
			'}',
			'void main() {',
			ShaderChunkModule.ShaderChunk['logdepthbuf_fragment'],
			'\t#ifdef USE_LOGDEPTHBUF_EXT',
			'\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );',
			'\t#else',
			'\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );',
			'\t#endif',
			//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
			//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
			//"gl_FragData[ 0 ] = pack_depth( z );",
			//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
			'}'
		].join('\n')
	}
};
exports.ShaderLib = ShaderLib;